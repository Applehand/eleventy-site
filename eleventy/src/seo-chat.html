---
title: AI Search Manual assistant
permalink: /geo-chat/
---

<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<style>
	/* === Brutalist look: high contrast, chunky borders, offset shadows === */
	:root{
		--ink:#000; --paper:#fff; --muted:#777; --pad:14px;
		--accent:#06c; --ok:#00c853; --warn:#ffab00; --err:#d50000;
	}
	*{box-sizing:border-box}
	body{
		background:var(--paper); color:var(--ink);
		font:16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
		max-width: 840px; margin: 40px auto; padding: 0 var(--pad); line-height:1.5;
	}
	h1{
		font: 800 28px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
		text-transform: uppercase; letter-spacing: .02em;
		margin: 0 0 8px 0;
	}
	.tagline{ margin: 0 0 12px; color:var(--muted); font-weight:600 }

	.card{
		border: 2.5px solid var(--ink);
		box-shadow: 8px 8px 0 var(--ink);
		border-radius: 8px;
		background: var(--paper);
		padding: var(--pad);
	}

	/* Disclosure box */
	details.disclosure{
		margin: 14px 0 6px;
		border: 2px solid var(--ink);
		border-radius: 8px;
		box-shadow: 6px 6px 0 var(--ink);
		background: var(--paper);
	}
	details.disclosure > summary{
		cursor: pointer;
		padding: 10px 14px;
		list-style: none;
		font-weight: 800;
		display:flex; align-items:center; gap:10px;
		border-bottom: 2px solid var(--ink);
	}
	details.disclosure[open] > summary{ background: #f5f5f5; }
	details.disclosure > summary::before{
		content: "▸"; display:inline-block; transform: translateY(-1px);
	}
	details.disclosure[open] > summary::before{ content:"▾"; }
	details.disclosure .content{ padding: 12px 14px; }

	/* Status bar */
	.statusbar{ display:flex; align-items:center; gap:10px; margin: 12px 0 18px; }
	.pill{
		display:inline-flex; align-items:center; gap:8px;
		border:2px solid var(--ink); padding:6px 12px; border-radius:999px;
		box-shadow: 3px 3px 0 var(--ink); font-weight:700; font-size:13px;
		background:var(--paper);
	}
	.dot{width:10px; height:10px; border-radius:50%; background:var(--muted); border:2px solid var(--ink)}
	.pill.ok .dot{ background:var(--ok); }
	.pill.warn .dot{ background:var(--warn); }
	.pill.err .dot{ background:var(--err); }
	.pill small{font-weight:600; color:var(--muted)}
	.grow{ flex:1 1 auto }

	/* Inputs + buttons */
	label{ font-weight:800; display:block; margin:8px 0 8px }
	textarea, input{
		width:100%; padding:12px; border:2px solid var(--ink); border-radius:10px; background:var(--paper);
		box-shadow: 4px 4px 0 var(--ink); font: inherit; resize: vertical; min-height: 96px;
	}
	.controls{ display:flex; gap:10px; flex-wrap:wrap; margin:12px 0 6px }
	.btn{
		border:2px solid var(--ink); background:var(--paper); padding:10px 14px; border-radius:10px;
		box-shadow:4px 4px 0 var(--ink); font-weight:800; cursor:pointer; user-select:none;
	}
	.btn:hover{ transform: translate(-2px,-2px); box-shadow:6px 6px 0 var(--ink); }
	.btn:active{ transform: translate(0,0); box-shadow:2px 2px 0 var(--ink); }
	.btn[disabled]{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:4px 4px 0 var(--ink); }

	/* Output panel */
	#outWrap{ position:relative; }
	#out{
		min-height: 160px; white-space: pre-wrap;
		border:2px dashed var(--ink); border-radius:10px; padding: var(--pad);
		background: #f7f7f7; box-shadow: inset 0 0 0 4px #fff;
	}
	/* Blinking caret while streaming */
	#caret{ display:none; }
	.streaming #caret{ display:inline-block; width:10px; height:1.1em; background:var(--ink); vertical-align:baseline; animation:blink 1s steps(1,end) infinite; }
	@keyframes blink{ 50%{ opacity:0 } }

	/* Top loading bar */
	#loader{
		display:none; height:12px; border:2px solid var(--ink); border-radius:10px; overflow:hidden;
		background: #fff; margin: 10px 0 16px; box-shadow:4px 4px 0 var(--ink);
	}
	.busy #loader{ display:block; }
	#loader::before{
		content:""; display:block; height:100%; width:40%;
		background: repeating-linear-gradient(45deg, var(--ink) 0 10px, #fff 10px 20px);
		position:relative; left:-40%; animation:slide 1.05s linear infinite;
	}
	@keyframes slide{ to { left: 100%; } }

	/* Small utilities */
	.mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
	.muted{ color: var(--muted) }
</style>

<h1>AI Search Manual GEOAssistant</h1>
<p class="tagline">
  A RAG-assisted GEO chatbot that answers with context from the
  <a href="https://ipullrank.com/ai-search-manual" target="_blank" rel="noopener">AI Search Manual</a>.
</p>

<details class="disclosure">
  <summary>..what?</summary>
  <div class="content">
    <p>
      This is a <strong>retrieval-augmented generation (RAG)</strong> demo. The AI Search Manual has been chunked and
      embedded into a <strong><a href="https://www.trychroma.com/">Chroma</a></strong> vector database. For each question, the app retrieves the most
      relevant chunks and prompts a local model (gpt-oss:20b from OpenAI's recent open source release) served by <strong><a href="https://ollama.com/">Ollama</a></strong> to compose an answer with context.
    </p>
    <p>
      The compute runs on my <strong>MacBook</strong> (<em>FastAPI + Ollama + Chroma</em>). This web UI and a tiny
      Flask proxy live on a <strong>Raspberry&nbsp;Pi</strong>. Requests flow
      <span class="mono">Browser → Pi → Mac (LAN)</span> and stream tokens back in real time.
      A <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/">Cloudflare Tunnel</a> exposes only the Pi, keeping the Mac private on my local network.
    </p>
  </div>
</details>

</details>

<div class="statusbar">
	<div id="apiPill" class="pill"><span class="dot"></span><span id="apiText">Checking API…</span> <small id="latency" class="muted mono"></small></div>
	<div class="grow"></div>
	<div class="pill" title="Pi → Mac">
		<span class="mono">LAN</span>
	</div>
</div>

<div id="loader" aria-hidden="true"></div>

<form id="f" class="card" autocomplete="off">
	<label for="q">Question</label>
	<textarea id="q" placeholder="Ask…">What does the AI Search Manual say about changes in user behavior?</textarea>

	<div class="controls">
		<button id="ask" class="btn">Ask (stream)</button>
		<button type="button" id="once" class="btn">Ask (non-stream)</button>
		<button type="button" id="cancel" class="btn" disabled>Cancel</button>
		<div class="grow"></div>
		<button type="button" id="copy" class="btn">Copy</button>
		<button type="button" id="clear" class="btn">Clear</button>
	</div>

	<div id="outWrap">
		<div id="out" class="mono" aria-live="polite"></div>
		<span id="caret" aria-hidden="true"></span>
	</div>
</form>

<script>
/* Config: same-origin /api; override with window.GEOCHAT_API for a subdomain */
const API_BASE = (window.GEOCHAT_API || "/api").replace(/\/$/, "");

const $ = (s)=>document.querySelector(s);
const bodyEl = document.body;
const apiPill = $("#apiPill"), apiText = $("#apiText"), latencyEl = $("#latency");
const out = $("#out"), caret = $("#caret");
const qEl = $("#q");
const askBtn = $("#ask"), onceBtn = $("#once"), cancelBtn = $("#cancel"), copyBtn = $("#copy"), clearBtn = $("#clear");
let controller = null;

function setBusy(b){
	bodyEl.classList.toggle("busy", b);
	askBtn.disabled = b; onceBtn.disabled = b; cancelBtn.disabled = !b;

	/* disable & blur textarea so the blinking caret disappears while generating */
	qEl.disabled = b;
	if (b) { qEl.blur(); }

	/* streaming visuals */
	out.parentElement.classList.toggle("streaming", b);
	caret.style.display = b ? "inline-block" : "none";
}
function autoScroll(){ out.scrollTop = out.scrollHeight; }

async function healthCheck(){
	try{
		const t0 = performance.now();
		const r = await fetch(`${API_BASE}/healthz`, { cache: "no-store" });
		const ms = Math.max(1, Math.round(performance.now()-t0));
		latencyEl.textContent = `~${ms}ms`;
		if(!r.ok) throw new Error(await r.text());
		const j = await r.json();
		if(j.ok){
			apiPill.classList.remove("warn","err"); apiPill.classList.add("ok");
			apiText.textContent = "API online";
		}else{
			apiPill.classList.remove("ok","err"); apiPill.classList.add("warn");
			apiText.textContent = "API not ready";
		}
	}catch(e){
		apiPill.classList.remove("ok","warn"); apiPill.classList.add("err");
		apiText.textContent = "API unreachable";
		latencyEl.textContent = "";
	}
}
healthCheck();

/* Keyboard: Enter to submit, Shift+Enter newline, Esc to cancel */
qEl.addEventListener("keydown",(e)=>{
	if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); askBtn.click(); }
	if(e.key==="Escape" && cancelBtn.disabled===false){ cancelBtn.click(); }
});

function renderError(msg){ out.textContent = `[error] ${msg}`; }

/* Non-streaming */
onceBtn.addEventListener("click", async ()=>{
	setBusy(true); out.textContent = "";
	try{
		const res = await fetch(`${API_BASE}/chat_once`, {
			method:"POST", headers:{ "Content-Type":"application/json" },
			body: JSON.stringify({ question: qEl.value })
		});
		const ct = res.headers.get("content-type") || "";
		if(!res.ok) throw new Error(await res.text());
		if(ct.includes("application/json")){
			const j = await res.json();
			out.textContent = j.text ?? JSON.stringify(j);
		}else{
			out.textContent = await res.text();
		}
	} catch(e){ renderError(e.message || e); }
	finally{ setBusy(false); }
});

/* Streaming */
$("#f").addEventListener("submit", async (e)=>{
	e.preventDefault();
	setBusy(true); out.textContent=""; controller = new AbortController();
	try{
		const res = await fetch(`${API_BASE}/chat`, {
			method:"POST", headers:{ "Content-Type":"application/json" },
			body: JSON.stringify({ question: qEl.value }),
			signal: controller.signal
		});
		if(!res.ok || !res.body) throw new Error(await res.text());
		const reader = res.body.getReader(); const dec = new TextDecoder();
		for(;;){
			const { value, done } = await reader.read();
			if(done) break;
			out.textContent += dec.decode(value, { stream:true });
			autoScroll();
		}
	}catch(e){
		if(e.name === "AbortError"){ out.textContent += "\n[stream canceled]"; }
		else{ renderError(e.message || e); }
	}finally{
		setBusy(false); controller = null;
	}
});

cancelBtn.addEventListener("click", ()=>{ if(controller) controller.abort(); });
copyBtn.addEventListener("click", async ()=>{
	try{ await navigator.clipboard.writeText(out.textContent); copyBtn.textContent="Copied!"; setTimeout(()=>copyBtn.textContent="Copy",900); }catch{}
});
clearBtn.addEventListener("click", ()=>{ out.textContent=""; qEl.focus(); });

/* Refresh status periodically */
setInterval(healthCheck, 15000);
</script>
